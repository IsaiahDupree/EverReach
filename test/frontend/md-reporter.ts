import type {
  FullConfig,
  FullResult,
  Reporter,
  Suite,
  TestCase,
  TestResult,
} from '@playwright/test/reporter';
import * as fs from 'fs';
import * as path from 'path';

class MarkdownReporter implements Reporter {
  private results: Array<{ test: TestCase; result: TestResult }> = [];
  private startTime: number = 0;

  onBegin(config: FullConfig, suite: Suite) {
    this.startTime = Date.now();
    console.log(`Starting test run with ${suite.allTests().length} tests`);
  }

  onTestEnd(test: TestCase, result: TestResult) {
    this.results.push({ test, result });
  }

  async onEnd(result: FullResult) {
    const duration = Date.now() - this.startTime;
    const report = this.generateMarkdownReport(result, duration);
    
    // Write to file
    const reportPath = path.join(__dirname, 'TEST_RESULTS.md');
    fs.writeFileSync(reportPath, report, 'utf-8');
    console.log(`\nüìù Test report saved to: ${reportPath}`);
  }

  private generateMarkdownReport(result: FullResult, duration: number): string {
    const total = this.results.length;
    const passed = this.results.filter(r => r.result.status === 'passed').length;
    const failed = this.results.filter(r => r.result.status === 'failed').length;
    const skipped = this.results.filter(r => r.result.status === 'skipped').length;

    const now = new Date();
    const timestamp = now.toLocaleString('en-US', {
      month: 'long',
      day: 'numeric',
      year: 'numeric',
      hour: 'numeric',
      minute: '2-digit',
      hour12: true
    });

    let md = `# Frontend E2E Test Results\n\n`;
    md += `**Last Run**: ${timestamp}  \n`;
    md += `**Duration**: ${(duration / 1000).toFixed(1)}s  \n`;
    md += `**Status**: ${result.status === 'passed' ? '‚úÖ PASSED' : '‚ùå FAILED'}  \n\n`;

    md += `## Summary\n\n`;
    md += `| Metric | Count |\n`;
    md += `|--------|-------|\n`;
    md += `| **Total** | ${total} |\n`;
    md += `| **Passed** | ‚úÖ ${passed} |\n`;
    md += `| **Failed** | ‚ùå ${failed} |\n`;
    md += `| **Skipped** | ‚è≠Ô∏è ${skipped} |\n`;
    md += `| **Pass Rate** | ${((passed / total) * 100).toFixed(1)}% |\n\n`;

    // Group by test file
    const byFile = new Map<string, Array<{ test: TestCase; result: TestResult }>>();
    for (const item of this.results) {
      const fileName = path.basename(item.test.location.file);
      if (!byFile.has(fileName)) {
        byFile.set(fileName, []);
      }
      byFile.get(fileName)!.push(item);
    }

    md += `## Test Details\n\n`;

    for (const [fileName, tests] of Array.from(byFile.entries()).sort()) {
      const filePassed = tests.filter(t => t.result.status === 'passed').length;
      const fileTotal = tests.length;
      const icon = filePassed === fileTotal ? '‚úÖ' : '‚ö†Ô∏è';
      
      md += `### ${icon} ${fileName.replace('.spec.ts', '')} (${filePassed}/${fileTotal})\n\n`;

      for (const { test, result } of tests) {
        const icon = result.status === 'passed' ? '‚úÖ' : result.status === 'failed' ? '‚ùå' : '‚è≠Ô∏è';
        const testName = test.title;
        const testDuration = (result.duration / 1000).toFixed(2);
        
        md += `- ${icon} **${testName}** (${testDuration}s)\n`;

        if (result.status === 'failed' && result.error) {
          md += `  - ‚ùå Error: ${result.error.message?.split('\n')[0] || 'Unknown error'}\n`;
        }
      }
      md += `\n`;
    }

    // Failed tests section
    if (failed > 0) {
      md += `## ‚ùå Failed Tests\n\n`;
      for (const { test, result } of this.results.filter(r => r.result.status === 'failed')) {
        md += `### ${test.title}\n\n`;
        md += `**File**: \`${path.basename(test.location.file)}\`  \n`;
        md += `**Duration**: ${(result.duration / 1000).toFixed(2)}s  \n\n`;
        
        if (result.error) {
          md += `**Error**:\n\`\`\`\n${result.error.message}\n\`\`\`\n\n`;
        }
      }
    }

    md += `---\n\n`;
    md += `*Generated by Playwright MD Reporter*\n`;

    return md;
  }
}

export default MarkdownReporter;
